# -*- coding: utf-8 -*-
"""app

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1duALCcNxymladL1yw_UezOFR7b2cmn9Q
"""

import streamlit as st
import tensorflow as tf
from tensorflow.keras.models import load_model
import numpy as np
import PIL.Image # Para abrir e pr√©-processar imagens do usu√°rio
import json # Para carregar os nomes das classes
import os # Para verificar se os arquivos existem
import gdown # Para baixar o modelo do Google Drive (se voc√™ usar essa abordagem)

# --- Caminhos dos Arquivos Salvos (ajuste seus IDs do Drive aqui se usar gdown) ---
MODEL_FILE_NAME = 'meu_modelo_gestos.keras'
CLASS_NAMES_FILE_NAME = 'class_names.json'

# --- **SUBSTITUA PELOS IDs REAIS DOS SEUS ARQUIVOS NO GOOGLE DRIVE** ---
# Ex: Se voc√™ upar meu_modelo_gestos.keras para o Drive, ele ter√° um ID.
MODEL_DRIVE_ID = 'SEU_ID_DO_MODELO_AQUI' # <--- OBRIGAT√ìRIO ATUALIZAR
CLASS_NAMES_DRIVE_ID = 'SEU_ID_DO_NOMES_CLASSES_AQUI' # <--- OBRIGAT√ìRIO ATUALIZAR

# --- Fun√ß√µes de Carregamento (usando st.cache_resource para performance) ---

@st.cache_resource
def download_file_from_drive(file_id, output_path):
    # Verifica se o arquivo j√° existe localmente para evitar download repetido
    if not os.path.exists(output_path):
        st.write(f"Baixando {output_path} do Google Drive...")
        try:
            gdown.download(f'https://drive.google.com/uc?id={file_id}', output_path, quiet=False)
            st.write(f"Download de {output_path} conclu√≠do.")
        except Exception as e:
            st.error(f"Erro ao baixar {output_path} do Google Drive: {e}")
            st.stop()
    else:
        st.write(f"{output_path} j√° existe localmente. Pulando download.")

@st.cache_resource
def load_gesture_model(model_path):
    download_file_from_drive(MODEL_DRIVE_ID, model_path)
    # Carrega o modelo Keras.
    # Quando o modelo foi salvo como .keras e inclui camadas de pr√©-processamento (como Rescaling, Data Augmentation),
    # ele as carrega automaticamente.
    model = load_model(model_path, compile=False) # compile=False evita recompilar desnecessariamente
    return model

@st.cache_resource
def load_class_names(class_names_path):
    download_file_from_drive(CLASS_NAMES_DRIVE_ID, class_names_path)
    with open(class_names_path, 'r') as f:
        class_names = json.load(f)
    return class_names

# --- Fun√ß√£o de Pr√©-processamento de Imagem para Previs√£o ---
def preprocess_image(image_data, target_height, target_width):
    # Abre a imagem usando PIL
    img = PIL.Image.open(image_data).convert('RGB') # Garante 3 canais de cor

    # Redimensiona a imagem para o tamanho alvo (altura x largura)
    img = img.resize((target_width, target_height))

    # Converte a imagem PIL para um array NumPy
    img_array = np.array(img, dtype=np.float32)

    # Adiciona uma dimens√£o de lote (batch dimension) no in√≠cio (necess√°rio para o modelo)
    # De (altura, largura, 3) para (1, altura, largura, 3)
    img_array = np.expand_dims(img_array, axis=0)

    # O modelo j√° inclui a camada Rescaling(1./255), ent√£o n√£o normalizamos aqui.
    # A camada de data_augmentation tamb√©m √© tratada deterministicamente na infer√™ncia pelo modelo.

    return img_array

# --- Fun√ß√£o Principal do Aplicativo Streamlit ---
def main():
    st.set_page_config(page_title="Classificador de Gestos de Linguagem de Sinais")

    st.title('üëã Classificador de Gestos de Linguagem de Sinais')
    st.markdown("Fa√ßa o upload de uma imagem de um gesto de linguagem de sinais para classific√°-lo.")

    # --- Carregar o Modelo e Nomes das Classes ---
    st.info("Preparando o classificador... Isso pode levar alguns segundos na primeira vez (baixando o modelo).")

    model = load_gesture_model(MODEL_FILE_NAME)
    class_names = load_class_names(CLASS_NAMES_FILE_NAME)

    st.success("Classificador pronto! Fa√ßa o upload de uma imagem.")

    st.write("---")
    st.subheader('Fa√ßa o upload da imagem do gesto:')
    uploaded_file = st.file_uploader("Arraste e solte uma imagem ou clique para selecionar", type=['png','jpg','jpeg'])

    if uploaded_file is not None:
        # Exibir a imagem carregada
        st.image(uploaded_file, caption='Imagem Carregada.', use_column_width=True)
        st.success('Imagem carregada com sucesso!')

        # Pr√©-processar a imagem
        # (altura, largura, 3) do treino = (50, 50, 3)
        processed_image = preprocess_image(uploaded_file, 50, 50)

        # Fazer a previs√£o
        with st.spinner('Analisando gesto...'):
            predictions = model.predict(processed_image)

            # As previs√µes s√£o probabilidades para cada classe (softmax)
            predicted_class_index = np.argmax(predictions)
            confidence = predictions[0][predicted_class_index] # Confian√ßa na classe prevista

            predicted_class_name = class_names[predicted_class_index]

        st.subheader('Resultado da Classifica√ß√£o:')
        st.write(f"O modelo prev√™ que o gesto √©: **{predicted_class_name}**")
        st.write(f"Confian√ßa do modelo: **{confidence*100:.2f}%**")

        if confidence > 0.8: # Um limite de confian√ßa que voc√™ pode ajustar
            st.balloons()

        st.write("---")
        st.subheader("Probabilidades para cada classe:")
        # Criar um DataFrame para exibir todas as probabilidades
        df_probs = pd.DataFrame({
            'Gesto': class_names,
            'Probabilidade (%)': predictions[0] * 100
        })
        df_probs = df_probs.sort_values(by='Probabilidade (%)', ascending=False)
        st.dataframe(df_probs.set_index('Gesto'))

    st.markdown("---")
    st.write("Desenvolvido com TensorFlow e Streamlit")
    st.write("Para treinar o modelo, execute `python model_trainer.py`, fa√ßa o upload dos arquivos `.keras` e `.json` para o Google Drive e atualize os IDs neste script.")

if __name__ == "__main__":
    main()